1. 자료구조 : 자료를 어떤 방식으로 구조화할 것인가를 정의 및 결정하는 요소

2. 알고리즘 : 어던 문제를 해결하기 위한 방법/솔루션

3. 자료구조에 따라 알고리즘 바뀔 수도 있고, 사용하고자하는 알고리즘에 따라 자료구조의 형태를 바꿔야할 수도 있다.


4. 코드의 효율성 체크 방법 : 시간 복잡도 개념 적용
- 빅오메가 : 어떤 문제를 해결하기 위한 알고리즘을 적용했을 때, 최고의 효율이 나는 경우에 한정 시간 측정
- 빅세타 : 평균적인 시간 측정
- 빅오 : 최악의 효율이 나는 경우 측정
실무에서는 빅오의 개념을 항상 적용 -> 외부의 물리적 변수에 최대한 영향을 받지 않는 환경에서 측정을 해야하기 때문에

5. 빅오의 시간복잡도 개념을 적용할 때 대원칙
- 연산처리의 세부적인 요소는 중요X
- 가장 시간을 많이 소비하는 요소를 기준으로 시간복잡도를 측정 => 반복문이 가장 많이 소비
- 이터러블한 객체 = 배열
- 어떤 경우 배열을 사용 VS 배열을 사용해서는 안되는 경우

6. 연결리스트 VS 배열 비교
- 배열 : 참조타입 변수, 배열에 들어오는 첫번재 인덱스 값만 찾으면 나머지 값들은 신속, 정확하게 찾아올 수 있는 장점, 전통적인 프로그래밍 언어들의 경우 배열 => 선언과 동시에 값을 픽스 & 사이즈를 저장(최초에 정의가 된 배열의 값을 수정, 편집 비효율적인 작업)
- 연결리스트 : 메모리 공간에 산발적으로 흩어져있는 데이터를 모아서 연결해놓은 자료구조, 데이터의 편집 및 수정이 매우 효율적, 연결리스트의 경우에는 산발적으로 흩어져있는 데이터이기 때문에 배열보다 초기 로딩 속도가 늦다

7. 연결리스트에서 자주 사용하는 기능 구현
- 추상자료형
- printAll()
- indexAt()
- clear()
- insertLast()
- deleteAt()
- getNodeAt()

8. stack 연결리스트 내 자료구조 형태
- stack : 무언가를 쌓아올리다
- 일상생활: 설거지, 엘리베이터 등.. First in Last out
- 입구, 출구 동일
- push() : 데이터를 삽입
- pop() : 데이터를 제거
- peek() : 데이터를 참조
- isEmpty() : 자료가 비어있는지 여부 확인

9. Queue 연결리스트 내 자료구조 형태
- queue : 대기하다, 기다리다라는 사전적 의미
- 일상생활 : 식당, 커피점 등 .. First in First out
- 입구, 출구 각각 독립
- enqueue() : 데이터를 삽입
- dequeue() : 데이터를 제거
- front() : 데이터를 참조
- isEmpty() : 자료가 비어있는지 여부 확인
> head & tail => 자료가 신규로 생성되는 위치 head 고정

10. deque 연결리스트 내 자료구조 형태
- Queue와 형태는 동일 + 자료 생성 & 삭제(head & tail)
- printAll() : 모든 데이터를 출력
- addFirst() : head에 데이터를 삽입
- removeFirst() : head에 데이터를 제거
- addLast() : tail에 데이터를 삽입
- removeLast() : tail에서 데이터를 제거
- isEmpty() : 해당 연결 리스트의 자료, 데이터가 비었는지 체크

11. HashTable:  연결리스트 내 자료구조 형태
- hash : # => Key
- table : 비효율적인 자료구조를 보다 효율적을 관리하기 위한 목적으로 테이블의 형식을 참조하여 자료구조를 세팅하는 방법
- hash Function: "해시함수" 메모리 공간에 비효율적으로 자리 잡고 있는 데이터를 효율적으로 보관, 관리해주는 기능을 가지고 있는 함수


안정적으로 데이터를 구현, 유지
신속 데이터를 확장

일반적 = 대중적
대부분의 기업 & 서비스 (B2C)
> 신속 & 정확하게 데이터 확장,제거, 편집

"시간 복잡도" 개념 : 어떤 특정 알고리즘을 활용해서 문제를 해결하는데 걸리는 시간

어떻게 계산?

O(3*n2 + n) = O(n2)
> 가장 시간을 많이 잡아먹는 비효율적인 부부난 직접 비교


프로그래밍 영역 시간을 가장 잡어먹는, 메모리 공간을 가장 비효율적으로 사용할 수 있도록 만들 확률이 가장 높은 요소 <-> 가장 효율적으로 만들 수도 있다

반복문 > 이터러블 객체 : 배열

배열 형태의 자료구조가 어떻게 되어있는가?
혹은 이 배열이라는 자료구조보다 더 효율적인 자료구조를 사용한다면?

선언형? 명령형?

1. 자료구조
2. 알고리즘
3. 시간복잡도
- 빅오메가
- 빅세타
- 빅오
4. 반복문 // 배열
5. 배열
- 장점 : 값 타입 // 사이즈 // 참조타입
- 단점 : 최초 배열 정의 // 수정 편집 매우 비효율 작업
6. 연결리스트
- 장점 : head, next
- 단점 : 최초 값을 찾아오는 것과 무관하게 모든 데이터 참조해야하기 때문에 초기 로딩은 효율적X
- 추상자료형 기능 함수 7개

------------------------------------------

stack 형태의 추상자료형 함수 구현
- 무언가를 쌓아올리다는 의미

연결리스트의 스택 추상자료형 함수 기능 4개를 구현
- push() : 연결리스트 데이터 삽입
- poo() : 연결리스트 데이터 제거
- peek() : 연결리스트 데이터  참조
- isEmpty() : 해당 연결리스트가 비어있는지 여부를 체크


